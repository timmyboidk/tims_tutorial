import type { Lesson } from '../types';

export const backendM4M6: Lesson[] = [
    {
        id: 'be-4-1', type: 'backend',
        title: '课程 4.1：Saga 模式与分布式事务',
        category: '模块4：复杂业务逻辑与弹性', track: '后端工程',
        moduleNumber: 4, lessonNumber: 1, language: 'java',
        startingCode: '',
        instructions: '# Saga 编排模式\n\n## 学习目标\n- 理解分布式事务的挑战（没有全局 ACID）\n- 使用 Saga 编排模式管理多服务事务\n- 实现补偿逻辑处理失败场景',
        diagramMarkup: 'graph TD\n    A["创建订单"] --> B["扣减库存"]\n    B -->|"成功"| C["发起支付"]\n    C -->|"成功"| D["订单完成"]\n    B -->|"失败"| E["取消订单"]\n    C -->|"失败"| F["回滚库存"]\n    F --> E\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E6F4EA,stroke:#34A853,color:#202124\n    style E fill:#FCE8E6,stroke:#EA4335,color:#202124\n    style F fill:#FEF7E0,stroke:#FBBC05,color:#202124',
        targetCode: 'package com.tutorial.service;\n\nimport com.tutorial.model.Order;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class OrderSagaService {\n    private static final Logger log = LoggerFactory.getLogger(OrderSagaService.class);\n    private final StockService stockService;\n    private final PaymentService paymentService;\n\n    public OrderSagaService(StockService stockService, PaymentService paymentService) {\n        this.stockService = stockService;\n        this.paymentService = paymentService;\n    }\n\n    public String executeOrderSaga(Order order) {\n        log.info("Saga started: orderId={}", order.getId());\n        boolean stockReserved = false;\n        try {\n            stockReserved = stockService.reserve(order.getItemId(), order.getQuantity());\n            if (!stockReserved) {\n                log.warn("Insufficient stock, cancelling");\n                return "FAILED_STOCK";\n            }\n            String paymentId = paymentService.processPayment(order.toPayment());\n            log.info("Payment initiated: {}", paymentId);\n            return paymentId;\n        } catch (Exception e) {\n            log.error("Saga failed, rolling back", e);\n            if (stockReserved) stockService.release(order.getItemId(), order.getQuantity());\n            return "FAILED";\n        }\n    }\n}\n',
        comments: [
            { line: 8, text: '// Saga 编排服务：协调库存和支付两个步骤' },
            { line: 19, text: '// 执行顺序：库存预留 -> 支付 -> 完成' },
            { line: 33, text: '// 补偿逻辑：支付失败时回滚已预留的库存' },
        ],
    },
    {
        id: 'be-4-2', type: 'backend',
        title: '课程 4.2：熔断机制（Resilience4j）',
        category: '模块4：复杂业务逻辑与弹性', track: '后端工程',
        moduleNumber: 4, lessonNumber: 2, language: 'java',
        startingCode: '',
        instructions: '# 熔断机制：优雅降级\n\n## 学习目标\n- 理解熔断器的三种状态：Closed、Open、Half-Open\n- 使用 Resilience4j 保护服务调用\n- 实现 Fallback 方法确保支付服务故障时不影响其他服务',
        diagramMarkup: 'graph TD\n    A["请求"] --> B{"熔断器状态"}\n    B -->|"Closed"| C["正常调用"]\n    B -->|"Open"| D["直接返回 Fallback"]\n    B -->|"Half-Open"| E["尝试性调用"]\n    C -->|"失败率超阈值"| D\n    E -->|"成功"| C\n    E -->|"失败"| D\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#FCE8E6,stroke:#EA4335,color:#202124\n    style E fill:#FEF7E0,stroke:#FBBC05,color:#202124',
        targetCode: 'package com.tutorial.service;\n\nimport io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport java.util.Map;\n\n@Service\npublic class PaymentGatewayService {\n    private static final Logger log = LoggerFactory.getLogger(PaymentGatewayService.class);\n\n    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")\n    public Map<String, Object> processPayment(String orderId, double amount) {\n        log.info("Processing payment: orderId={}, amount={}", orderId, amount);\n        return callExternalPaymentApi(orderId, amount);\n    }\n\n    private Map<String, Object> callExternalPaymentApi(String orderId, double amount) {\n        return Map.of("orderId", orderId, "status", "COMPLETED", "amount", amount);\n    }\n\n    public Map<String, Object> paymentFallback(String orderId, double amount, Throwable t) {\n        log.warn("Payment circuit breaker opened for order: {}, error: {}", orderId, t.getMessage());\n        return Map.of(\n                "orderId", orderId,\n                "status", "PENDING_RETRY",\n                "message", "Payment service temporarily unavailable",\n                "amount", amount);\n    }\n}\n',
        comments: [
            { line: 13, text: '// @CircuitBreaker：失败率超阈值时自动打开熔断器' },
            { line: 14, text: '// 正常路径：调用外部支付 API' },
            { line: 23, text: '// Fallback：熔断打开时返回降级响应，订单标记为待重试' },
        ],
    },
    {
        id: 'be-4-task', type: 'backend',
        title: '实战：端到端结账 + 熔断降级',
        category: '模块4：复杂业务逻辑与弹性', track: '后端工程',
        moduleNumber: 4, lessonNumber: 3, language: 'java',
        startingCode: '',
        instructions: '# 启发式任务：结账流程 + 熔断\n\n## 任务目标\n构建端到端结账：订单触发 Kafka 事件，尝试支付（模拟失败触发熔断），优雅返回备选响应。',
        targetCode: 'package com.tutorial.controller;\n\nimport com.tutorial.service.OrderSagaService;\nimport com.tutorial.service.PaymentGatewayService;\nimport com.tutorial.model.Order;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport java.util.Map;\n\n@RestController\n@RequestMapping("/api/checkout")\npublic class CheckoutController {\n    private final OrderSagaService sagaService;\n    private final PaymentGatewayService paymentGateway;\n\n    public CheckoutController(OrderSagaService sagaService,\n                              PaymentGatewayService paymentGateway) {\n        this.sagaService = sagaService;\n        this.paymentGateway = paymentGateway;\n    }\n\n    @PostMapping\n    public ResponseEntity<?> checkout(@RequestBody Order order) {\n        String sagaResult = sagaService.executeOrderSaga(order);\n        if (sagaResult.startsWith("FAILED")) {\n            return ResponseEntity.status(409).body(Map.of(\n                    "orderId", order.getId(), "status", sagaResult));\n        }\n\n        Map<String, Object> paymentResult = paymentGateway.processPayment(\n                order.getId(), order.getTotalAmount());\n        return ResponseEntity.status(201).body(paymentResult);\n    }\n}\n',
        comments: [
            { line: 10, text: '// 结账控制器：编排 Saga + 支付（含熔断保护）' },
            { line: 24, text: '// Saga 先行：库存检查失败直接返回 409 Conflict' },
            { line: 30, text: '// 支付调用：如果服务故障，@CircuitBreaker 返回 Fallback' },
        ],
    },
    {
        id: 'be-5-1', type: 'backend',
        title: '课程 5.1：可观测性 — Micrometer 与 OpenTelemetry',
        category: '模块5：可观测性与追踪', track: '后端工程',
        moduleNumber: 5, lessonNumber: 1, language: 'java',
        startingCode: '',
        instructions: '# 可观测性：集成 Micrometer 和 OpenTelemetry\n\n## 学习目标\n- 理解可观测性三大支柱：Metrics、Logs、Traces\n- 使用 Micrometer 暴露应用指标\n- 集成 OpenTelemetry 实现自动检测',
        diagramMarkup: 'graph LR\n    A["Spring Boot"] -->|"Metrics"| B["Micrometer"]\n    A -->|"Traces"| C["OpenTelemetry"]\n    B --> D["Prometheus"]\n    C --> E["Jaeger / Zipkin"]\n    D --> F["Grafana 仪表盘"]\n    E --> F\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E6F4EA,stroke:#34A853,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style E fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style F fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial.config;\n\nimport io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.micrometer.core.instrument.Timer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MetricsConfig {\n\n    @Bean\n    public Counter orderCounter(MeterRegistry registry) {\n        return Counter.builder("orders.created.total")\n                .description("Total orders created")\n                .register(registry);\n    }\n\n    @Bean\n    public Counter paymentFailureCounter(MeterRegistry registry) {\n        return Counter.builder("payments.failed.total")\n                .description("Total failed payments")\n                .tag("reason", "circuit_breaker")\n                .register(registry);\n    }\n\n    @Bean\n    public Timer checkoutTimer(MeterRegistry registry) {\n        return Timer.builder("checkout.duration")\n                .description("Time taken for checkout process")\n                .publishPercentiles(0.5, 0.95, 0.99)\n                .register(registry);\n    }\n}\n',
        comments: [
            { line: 9, text: '// Metrics 配置：注册计数器和计时器' },
            { line: 13, text: '// Counter：单调递增的计数器，追踪事件总量' },
            { line: 28, text: '// Timer：记录耗时分布，发布 P50/P95/P99 分位数' },
        ],
    },
    {
        id: 'be-5-2', type: 'backend',
        title: '课程 5.2：分布式追踪',
        category: '模块5：可观测性与追踪', track: '后端工程',
        moduleNumber: 5, lessonNumber: 2, language: 'java',
        startingCode: '',
        instructions: '# 分布式追踪\n\n## 学习目标\n- 追踪单个请求在 API、Redis 和 Kafka 中的完整链路\n- 使用 Spring Boot Actuator + Micrometer Tracing\n- 将 Trace ID 注入到日志和响应头中',
        diagramMarkup: 'graph LR\n    A["API Gateway"] -->|"traceId"| B["OrderService"]\n    B -->|"traceId"| C["Redis Cache"]\n    B -->|"traceId"| D["Kafka Producer"]\n    D -->|"traceId"| E["PaymentConsumer"]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style E fill:#FEF7E0,stroke:#FBBC05,color:#202124',
        targetCode: 'package com.tutorial.filter;\n\nimport io.micrometer.tracing.Tracer;\nimport jakarta.servlet.FilterChain;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport java.io.IOException;\n\n@Component\npublic class TraceIdFilter extends OncePerRequestFilter {\n    private final Tracer tracer;\n\n    public TraceIdFilter(Tracer tracer) {\n        this.tracer = tracer;\n    }\n\n    @Override\n    protected void doFilterInternal(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain) throws ServletException, IOException {\n\n        String traceId = tracer.currentSpan() != null\n                ? tracer.currentSpan().context().traceId()\n                : "no-trace";\n\n        response.setHeader("X-Trace-Id", traceId);\n        org.slf4j.MDC.put("traceId", traceId);\n\n        try {\n            filterChain.doFilter(request, response);\n        } finally {\n            org.slf4j.MDC.remove("traceId");\n        }\n    }\n}\n',
        comments: [
            { line: 12, text: '// OncePerRequestFilter：每个请求只执行一次' },
            { line: 26, text: '// 从 Micrometer Tracer 获取当前 Trace ID' },
            { line: 30, text: '// 注入响应头：前端可在 DevTools 中查看' },
            { line: 31, text: '// MDC.put：Trace ID 会自动附加到所有日志输出' },
        ],
    },
    {
        id: 'be-5-task', type: 'backend',
        title: '实战：注入 Trace ID 并可视化请求路径',
        category: '模块5：可观测性与追踪', track: '后端工程',
        moduleNumber: 5, lessonNumber: 3, language: 'java',
        startingCode: '',
        instructions: '# 启发式任务：将 Trace ID 注入结账流程\n\n## 任务目标\n在结账流程的 Kafka 消息头中注入 Trace ID，实现端到端链路追踪。',
        targetCode: 'package com.tutorial.service;\n\nimport io.micrometer.tracing.Tracer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.header.internals.RecordHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.stereotype.Service;\nimport java.nio.charset.StandardCharsets;\n\n@Service\npublic class TracedEventPublisher {\n    private static final Logger log = LoggerFactory.getLogger(TracedEventPublisher.class);\n    private final KafkaTemplate<String, String> kafkaTemplate;\n    private final Tracer tracer;\n\n    public TracedEventPublisher(KafkaTemplate<String, String> kafkaTemplate, Tracer tracer) {\n        this.kafkaTemplate = kafkaTemplate;\n        this.tracer = tracer;\n    }\n\n    public void publish(String topic, String key, String payload) {\n        ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, payload);\n\n        String traceId = tracer.currentSpan() != null\n                ? tracer.currentSpan().context().traceId()\n                : "unknown";\n\n        record.headers().add(new RecordHeader(\n                "X-Trace-Id", traceId.getBytes(StandardCharsets.UTF_8)));\n\n        log.info("Publishing event: topic={}, key={}, traceId={}", topic, key, traceId);\n        kafkaTemplate.send(record);\n    }\n}\n',
        comments: [
            { line: 12, text: '// 带追踪的事件发布器：自动注入 Trace ID' },
            { line: 26, text: '// 从 Tracer 获取当前 Span 的 Trace ID' },
            { line: 30, text: '// Kafka Header 注入：消费者可从 Header 中读取 Trace ID' },
        ],
    },
    {
        id: 'be-6-1', type: 'backend',
        title: '课程 6.1：Docker 基础 — Dockerfile 与 Compose',
        category: '模块6：容器化与编排', track: '后端工程',
        moduleNumber: 6, lessonNumber: 1, language: 'dockerfile',
        startingCode: '',
        instructions: '# Docker 基础\n\n## 学习目标\n- 编写多阶段 Dockerfile 构建 Spring Boot 镜像\n- 使用 Docker Compose 编排应用与 Redis、Kafka 依赖\n- 理解镜像分层与缓存优化',
        diagramMarkup: 'graph TD\n    A["docker-compose.yml"] --> B["Spring Boot"]\n    A --> C["Redis"]\n    A --> D["Kafka"]\n    A --> E["MySQL"]\n    B -->|"depends_on"| C\n    B -->|"depends_on"| D\n    B -->|"depends_on"| E\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style E fill:#E6F4EA,stroke:#34A853,color:#202124',
        targetCode: 'FROM eclipse-temurin:21-jdk-alpine AS builder\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\nRUN apk add --no-cache maven \\\n    && mvn package -DskipTests -q \\\n    && mv target/*.jar app.jar\n\nFROM eclipse-temurin:21-jre-alpine\nWORKDIR /app\nCOPY --from=builder /app/app.jar .\nEXPOSE 8080\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD wget -qO- http://localhost:8080/actuator/health || exit 1\nENTRYPOINT ["java", "-jar", "app.jar"]\n',
        comments: [
            { line: 1, text: '// 第一阶段：JDK 镜像用于编译，最终镜像只含 JRE' },
            { line: 5, text: '// 安装 Maven 并构建，跳过测试加速构建' },
            { line: 9, text: '// 第二阶段：仅包含 JRE 的精简运行时镜像' },
            { line: 13, text: '// HEALTHCHECK：K8s 和 Docker 用此检测容器健康' },
        ],
    },
    {
        id: 'be-6-2', type: 'backend',
        title: '课程 6.2：Kubernetes 基础 — Pod、Deployment 和 Service',
        category: '模块6：容器化与编排', track: '后端工程',
        moduleNumber: 6, lessonNumber: 2, language: 'yaml',
        startingCode: '',
        instructions: '# Kubernetes 基础\n\n## 学习目标\n- 理解 Pod、Deployment、Service 三层抽象\n- Pod = 最小调度单元，包含一个或多个容器\n- Deployment = 声明式管理 Pod 副本数和滚动更新\n- Service = 稳定的网络端点，负载均衡到后端 Pod',
        diagramMarkup: 'graph TD\n    A["Service :8080"] --> B["Pod 1"]\n    A --> C["Pod 2"]\n    A --> D["Pod 3"]\n    E["Deployment"] -->|"管理"| B\n    E -->|"管理"| C\n    E -->|"管理"| D\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E6F4EA,stroke:#34A853,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#E6F4EA,stroke:#34A853,color:#202124\n    style E fill:#FEF7E0,stroke:#FBBC05,color:#202124',
        targetCode: 'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: codeforge-api\n  labels:\n    app: codeforge-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: codeforge-api\n  template:\n    metadata:\n      labels:\n        app: codeforge-api\n    spec:\n      containers:\n        - name: api\n          image: codeforge/api:latest\n          ports:\n            - containerPort: 8080\n          env:\n            - name: SPRING_PROFILES_ACTIVE\n              value: "prod"\n            - name: REDIS_HOST\n              valueFrom:\n                configMapKeyRef:\n                  name: app-config\n                  key: redis-host\n          resources:\n            requests:\n              memory: "256Mi"\n              cpu: "250m"\n            limits:\n              memory: "512Mi"\n              cpu: "500m"\n          readinessProbe:\n            httpGet:\n              path: /actuator/health\n              port: 8080\n            initialDelaySeconds: 10\n            periodSeconds: 5\n',
        comments: [
            { line: 2, text: '// Deployment：声明式管理 Pod 的期望状态' },
            { line: 8, text: '// replicas: 3 — 始终保持3个 Pod 实例运行' },
            { line: 22, text: '// 环境变量：从 ConfigMap 注入配置，不硬编码' },
            { line: 30, text: '// 资源限制：防止单个 Pod 耗尽节点资源' },
            { line: 37, text: '// 就绪探针：Pod 健康后才接收流量' },
        ],
    },
    {
        id: 'be-6-3', type: 'backend',
        title: '课程 6.3：K8s YAML 清单与自动扩展',
        category: '模块6：容器化与编排', track: '后端工程',
        moduleNumber: 6, lessonNumber: 3, language: 'yaml',
        startingCode: '',
        instructions: '# K8s Service 与 HPA 自动扩展\n\n## 学习目标\n- 编写 Service YAML 暴露 Deployment\n- 配置 HPA（Horizontal Pod Autoscaler）基于 CPU 自动扩缩\n- 理解 ClusterIP、NodePort、LoadBalancer 类型',
        targetCode: 'apiVersion: v1\nkind: Service\nmetadata:\n  name: codeforge-api-svc\nspec:\n  type: ClusterIP\n  selector:\n    app: codeforge-api\n  ports:\n    - port: 80\n      targetPort: 8080\n      protocol: TCP\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: codeforge-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: codeforge-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n',
        comments: [
            { line: 2, text: '// Service：为 Deployment 提供稳定的 DNS 名称和负载均衡' },
            { line: 6, text: '// ClusterIP：仅集群内部可访问，生产环境用 Ingress 暴露' },
            { line: 14, text: '// HPA：根据 CPU 使用率自动扩缩 Pod 数量' },
            { line: 23, text: '// 最少2个副本保证高可用，最多10个应对流量峰值' },
            { line: 31, text: '// CPU 超过70%时触发扩容' },
        ],
    },
    {
        id: 'be-6-task', type: 'backend',
        title: '实战：容器化后端 + K8s 部署',
        category: '模块6：容器化与编排', track: '后端工程',
        moduleNumber: 6, lessonNumber: 4, language: 'yaml',
        startingCode: '',
        instructions: '# 启发式任务：容器化整个后端并部署到 Kubernetes\n\n## 任务目标\n编写 docker-compose.yml 编排所有服务，并编写 K8s Deployment 清单用于 Minikube 本地部署。',
        targetCode: 'version: "3.9"\nservices:\n  api:\n    build: .\n    ports:\n      - "8080:8080"\n    environment:\n      SPRING_PROFILES_ACTIVE: docker\n      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/codeforge\n      SPRING_REDIS_HOST: redis\n      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:9092\n    depends_on:\n      mysql:\n        condition: service_healthy\n      redis:\n        condition: service_started\n      kafka:\n        condition: service_started\n\n  mysql:\n    image: mysql:8.0\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n      MYSQL_DATABASE: codeforge\n    ports:\n      - "3306:3306"\n    healthcheck:\n      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - "6379:6379"\n\n  kafka:\n    image: confluentinc/cp-kafka:7.5.0\n    ports:\n      - "9092:9092"\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n\n  zookeeper:\n    image: confluentinc/cp-zookeeper:7.5.0\n    environment:\n      ZOOKEEPER_CLIENT_PORT: 2181\n',
        comments: [
            { line: 3, text: '// api 服务：从当前目录的 Dockerfile 构建' },
            { line: 12, text: '// depends_on + healthcheck：确保 MySQL 就绪后才启动 API' },
            { line: 38, text: '// Kafka + Zookeeper：完整的事件驱动中间件' },
        ],
    },
];
