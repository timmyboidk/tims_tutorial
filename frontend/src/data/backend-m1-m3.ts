import type { Lesson } from '../types';

export const backendM1M3: Lesson[] = [
    {
        id: 'be-1-1', type: 'backend',
        title: '课程 1.1：Spring Boot 初始化与依赖注入',
        category: '模块1：Spring Boot 核心与性能', track: '后端工程',
        moduleNumber: 1, lessonNumber: 1, language: 'java',
        startingCode: '',
        instructions: '# Spring Boot 3.x 初始化\n\n## 学习目标\n- 理解 Spring Boot 自动配置原理\n- 掌握构造器注入\n- 了解 MVC 分层架构：Controller -> Service -> Mapper',
        diagramMarkup: 'graph TD\n    A["HTTP 请求"] --> B["DispatcherServlet"]\n    B --> C["Controller"]\n    C --> D["Service"]\n    D --> E["Mapper"]\n    E --> F[("MySQL")]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style E fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style F fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class CodeForgeApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(CodeForgeApplication.class, args);\n    }\n}\n',
        comments: [
            { line: 6, text: '// @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan' },
            { line: 9, text: '// 入口方法：启动嵌入式 Tomcat 并初始化 IoC 容器' },
        ],
    },
    {
        id: 'be-1-2', type: 'backend',
        title: '课程 1.2：设置 MyBatis 作为 ORM',
        category: '模块1：Spring Boot 核心与性能', track: '后端工程',
        moduleNumber: 1, lessonNumber: 2, language: 'java',
        startingCode: '',
        instructions: '# MyBatis ORM 与数据库模式设计\n\n## 学习目标\n- 理解 Mapper 接口 + XML 映射模式\n- 掌握 @Mapper、@Param 注解\n- 设计规范化的数据库表结构',
        diagramMarkup: 'graph LR\n    A["Java 接口"] -->|"@Mapper"| B["MyBatis 代理"]\n    B --> C["XML 映射"]\n    C -->|"SQL"| D[("MySQL")]\n    D -->|"ResultMap"| E["Java 对象"]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style E fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial.mapper;\n\nimport com.tutorial.model.User;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\n@Mapper\npublic interface UserMapper {\n    User findById(@Param("id") Long id);\n    User findByUsername(@Param("username") String username);\n    List<User> findAll();\n    int insert(User user);\n    int update(User user);\n    int deleteById(@Param("id") Long id);\n}\n',
        comments: [
            { line: 9, text: '// @Mapper 标记为 MyBatis 映射接口，Spring 自动创建代理' },
            { line: 11, text: '// @Param 绑定方法参数到 XML 中的占位符' },
        ],
    },
    {
        id: 'be-1-3', type: 'backend',
        title: '课程 1.3：GraalVM 原生镜像',
        category: '模块1：Spring Boot 核心与性能', track: '后端工程',
        moduleNumber: 1, lessonNumber: 3, language: 'java',
        startingCode: '',
        instructions: '# GraalVM 原生镜像：毫秒级启动\n\n## 学习目标\n- 将 Spring Boot 编译为独立的原生可执行文件\n- 理解 AOT（Ahead-of-Time）编译与 JIT 的区别\n- 配置 Native Build Tools 插件\n\n## 核心优势\n- 启动时间：约 50ms（JVM 约 2-3秒）\n- 内存占用：约 50MB（JVM 约 200-300MB）\n- 对快速自动扩展（Serverless、K8s HPA）至关重要',
        diagramMarkup: 'graph LR\n    A["Java 源码"] --> B["AOT 编译"]\n    B --> C["GraalVM native-image"]\n    C --> D["原生可执行文件"]\n    D -->|"50ms 启动"| E["运行中"]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E6F4EA,stroke:#34A853,color:#202124\n    style E fill:#E6F4EA,stroke:#34A853,color:#202124',
        targetCode: 'package com.tutorial.config;\n\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.RuntimeHintsRegistrar;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ImportRuntimeHints;\n\n@Configuration\n@ImportRuntimeHints(NativeConfig.Hints.class)\npublic class NativeConfig {\n\n    static class Hints implements RuntimeHintsRegistrar {\n        @Override\n        public void registerHints(RuntimeHints hints, ClassLoader classLoader) {\n            hints.reflection()\n                    .registerType(com.tutorial.model.User.class);\n            hints.reflection()\n                    .registerType(com.tutorial.model.Stock.class);\n            hints.resources()\n                    .registerPattern("mapper/*.xml");\n        }\n    }\n}\n',
        comments: [
            { line: 8, text: '// @ImportRuntimeHints：注册 AOT 编译所需的反射元数据' },
            { line: 12, text: '// RuntimeHintsRegistrar：GraalVM 需要显式声明反射类型' },
            { line: 15, text: '// 注册实体类：AOT 编译无法自动检测 JSON 序列化用的反射' },
            { line: 19, text: '// 注册资源文件：MyBatis XML 映射文件需在编译期包含' },
        ],
    },
    {
        id: 'be-1-task', type: 'backend',
        title: '实战：构建原生编译 REST API',
        category: '模块1：Spring Boot 核心与性能', track: '后端工程',
        moduleNumber: 1, lessonNumber: 4, language: 'java',
        startingCode: '',
        instructions: '# 启发式任务：原生编译的用户和库存 REST API\n\n## 任务目标\n构建一个 REST 控制器，支持增删改查，并能通过 GraalVM 编译为原生镜像。',
        diagramMarkup: 'graph TD\n    A["客户端"] -->|"HTTP"| B["StockController"]\n    B --> C["StockService"]\n    C --> D["StockMapper"]\n    D --> E[("MySQL")]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style E fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial.controller;\n\nimport com.tutorial.model.Stock;\nimport com.tutorial.service.StockService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport java.util.List;\n\n@RestController\n@RequestMapping("/api/stocks")\npublic class StockController {\n    private final StockService stockService;\n\n    public StockController(StockService stockService) {\n        this.stockService = stockService;\n    }\n\n    @GetMapping\n    public ResponseEntity<List<Stock>> getAllStocks() {\n        return ResponseEntity.ok(stockService.findAll());\n    }\n\n    @GetMapping("/{id}")\n    public ResponseEntity<Stock> getById(@PathVariable Long id) {\n        Stock stock = stockService.findById(id);\n        if (stock == null) return ResponseEntity.notFound().build();\n        return ResponseEntity.ok(stock);\n    }\n\n    @PostMapping\n    public ResponseEntity<Stock> create(@RequestBody Stock stock) {\n        return ResponseEntity.status(201).body(stockService.create(stock));\n    }\n\n    @DeleteMapping("/{id}")\n    public ResponseEntity<Void> delete(@PathVariable Long id) {\n        stockService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n',
        comments: [
            { line: 9, text: '// @RestController = @Controller + @ResponseBody' },
            { line: 14, text: '// 构造器注入：保证不可变性和可测试性' },
        ],
    },
    {
        id: 'be-2-1', type: 'backend',
        title: '课程 2.1：实现 JWT 身份验证',
        category: '模块2：Redis 缓存与安全', track: '后端工程',
        moduleNumber: 2, lessonNumber: 1, language: 'java',
        startingCode: '',
        instructions: '# JWT 身份验证\n\n## 学习目标\n- 理解 JWT 结构：Header.Payload.Signature\n- 使用 jjwt 库生成和验证令牌\n- 实现令牌创建、解析和过期检查',
        diagramMarkup: 'graph LR\n    A["登录"] --> B["验证密码"]\n    B -->|"成功"| C["生成 JWT"]\n    C --> D["返回 Token"]\n    D --> E["携带 Token"]\n    E --> F["JwtFilter 验证"]\n    style A fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style B fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style C fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style D fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style E fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style F fill:#FEF7E0,stroke:#FBBC05,color:#202124',
        targetCode: 'package com.tutorial.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.security.Keys;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport javax.crypto.SecretKey;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.Map;\n\n@Component\npublic class JwtUtil {\n    private final SecretKey key;\n    private final long expiration;\n\n    public JwtUtil(@Value("${"+"jwt.secret}") String secret,\n                   @Value("${"+"jwt.expiration}") long expiration) {\n        this.key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));\n        this.expiration = expiration;\n    }\n\n    public String generateToken(String username, String role) {\n        return Jwts.builder()\n                .claims(Map.of("role", role))\n                .subject(username)\n                .issuedAt(new Date())\n                .expiration(new Date(System.currentTimeMillis() + expiration))\n                .signWith(key)\n                .compact();\n    }\n\n    public String extractUsername(String token) {\n        return extractClaims(token).getSubject();\n    }\n\n    public boolean validateToken(String token, String username) {\n        return extractUsername(token).equals(username) && !isExpired(token);\n    }\n\n    private boolean isExpired(String token) {\n        return extractClaims(token).getExpiration().before(new Date());\n    }\n\n    private Claims extractClaims(String token) {\n        return Jwts.parser().verifyWith(key).build()\n                .parseSignedClaims(token).getPayload();\n    }\n}\n',
        comments: [
            { line: 13, text: '// @Component 注册为 Spring Bean' },
            { line: 24, text: '// 生成 Token：包含用户名、角色、过期时间' },
        ],
    },
    {
        id: 'be-2-2', type: 'backend',
        title: '课程 2.2：Redis 会话管理与缓存',
        category: '模块2：Redis 缓存与安全', track: '后端工程',
        moduleNumber: 2, lessonNumber: 2, language: 'java',
        startingCode: '',
        instructions: '# 使用 Redis 进行会话管理和缓存\n\n## 学习目标\n- 配置 RedisTemplate 和序列化器\n- 使用 Redis 缓存高频数据库查询\n- 实现 Token 黑名单和会话存储',
        diagramMarkup: 'graph LR\n    A["Service"] -->|"查缓存"| B["Redis"]\n    B -->|"命中"| C["返回"]\n    A -->|"未命中"| D[("MySQL")]\n    D -->|"写缓存"| B\n    style A fill:#E6F4EA,stroke:#34A853,color:#202124\n    style B fill:#E6F4EA,stroke:#34A853,color:#202124\n    style C fill:#E6F4EA,stroke:#34A853,color:#202124\n    style D fill:#E6F4EA,stroke:#34A853,color:#202124',
        targetCode: 'package com.tutorial.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(\n            RedisConnectionFactory connectionFactory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n',
        comments: [
            { line: 10, text: '// @Configuration 标记为配置类' },
            { line: 17, text: '// Key 序列化器：String 方便 CLI 查看' },
            { line: 19, text: '// Value 序列化器：JSON 格式存储对象' },
        ],
    },
    {
        id: 'be-2-task', type: 'backend',
        title: '实战：基于 Redis 的 JWT 安全 API',
        category: '模块2：Redis 缓存与安全', track: '后端工程',
        moduleNumber: 2, lessonNumber: 3, language: 'java',
        startingCode: '',
        instructions: '# 启发式任务：JWT 认证控制器 + Redis Token 缓存\n\n## 任务目标\n实现完整的认证控制器，并将 JWT 缓存到 Redis 中。',
        diagramMarkup: 'graph TD\n    A["POST /register"] --> B["AuthService"]\n    B -->|"加密"| C["BCrypt"]\n    B -->|"保存"| D["UserMapper"]\n    B -->|"令牌"| E["JwtUtil"]\n    E -->|"缓存"| F["Redis"]\n    E --> G["返回 JWT"]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style E fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style F fill:#E6F4EA,stroke:#34A853,color:#202124\n    style G fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial.controller;\n\nimport com.tutorial.service.AuthService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport java.util.Map;\n\n@RestController\n@RequestMapping("/api/auth")\npublic class AuthController {\n    private final AuthService authService;\n\n    public AuthController(AuthService authService) {\n        this.authService = authService;\n    }\n\n    @PostMapping("/register")\n    public ResponseEntity<?> register(@RequestBody Map<String, String> req) {\n        try {\n            Map<String, Object> result = authService.register(\n                    req.get("username"), req.get("email"), req.get("password"));\n            return ResponseEntity.status(201).body(result);\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));\n        }\n    }\n\n    @PostMapping("/login")\n    public ResponseEntity<?> login(@RequestBody Map<String, String> req) {\n        try {\n            return ResponseEntity.ok(authService.login(req.get("username"), req.get("password")));\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.status(401).body(Map.of("error", e.getMessage()));\n        }\n    }\n}\n',
        comments: [
            { line: 8, text: '// 认证控制器：/api/auth/** 配置为公开路径' },
            { line: 17, text: '// POST /register：注册新用户，成功返回 201' },
        ],
    },
    {
        id: 'be-3-1', type: 'backend',
        title: '课程 3.1：Kafka 消息代理基础',
        category: '模块3：事件驱动与容错', track: '后端工程',
        moduleNumber: 3, lessonNumber: 1, language: 'java',
        startingCode: '',
        instructions: '# Kafka 消息代理\n\n## 学习目标\n- 理解 Topic、Partition、Consumer Group\n- 配置 Spring Kafka Topic 自动创建\n- 掌握 Producer/Consumer 协作模式',
        diagramMarkup: 'graph LR\n    A["Producer"] -->|"发送"| B["Kafka Topic"]\n    B -->|"分区0"| C["Consumer A"]\n    B -->|"分区1"| D["Consumer B"]\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style C fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style D fill:#E8F0FE,stroke:#4285F4,color:#202124',
        targetCode: 'package com.tutorial.config;\n\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.kafka.config.TopicBuilder;\n\n@Configuration\npublic class KafkaConfig {\n    public static final String ORDER_TOPIC = "order-events";\n    public static final String PAYMENT_TOPIC = "payment-events";\n    public static final String DLQ_TOPIC = "order-events.DLQ";\n\n    @Bean\n    public NewTopic orderTopic() {\n        return TopicBuilder.name(ORDER_TOPIC).partitions(3).replicas(1).build();\n    }\n\n    @Bean\n    public NewTopic paymentTopic() {\n        return TopicBuilder.name(PAYMENT_TOPIC).partitions(3).replicas(1).build();\n    }\n\n    @Bean\n    public NewTopic dlqTopic() {\n        return TopicBuilder.name(DLQ_TOPIC).partitions(1).replicas(1).build();\n    }\n}\n',
        comments: [
            { line: 8, text: '// Kafka 配置类：启动时自动创建 Topic' },
            { line: 12, text: '// DLQ Topic：死信队列，存放无法处理的消息' },
            { line: 16, text: '// partitions(3)：3个分区支持3个消费者并行消费' },
        ],
    },
    {
        id: 'be-3-2', type: 'backend',
        title: '课程 3.2：Kafka 死信队列与重试路由',
        category: '模块3：事件驱动与容错', track: '后端工程',
        moduleNumber: 3, lessonNumber: 2, language: 'java',
        startingCode: '',
        instructions: '# Kafka 高级容错：DLQ 与重试\n\n## 学习目标\n- 配置死信队列（DLQ）捕获无法处理的消息\n- 实现条件重试路由：可恢复错误重试，不可恢复错误直接进入 DLQ\n- 使用 DefaultErrorHandler 和 DeadLetterPublishingRecoverer',
        diagramMarkup: 'graph TD\n    A["Kafka Consumer"] -->|"处理成功"| B["正常完成"]\n    A -->|"失败"| C["重试 3 次"]\n    C -->|"仍失败"| D["DLQ Topic"]\n    C -->|"重试成功"| B\n    style A fill:#E8F0FE,stroke:#4285F4,color:#202124\n    style B fill:#E6F4EA,stroke:#34A853,color:#202124\n    style C fill:#FEF7E0,stroke:#FBBC05,color:#202124\n    style D fill:#FCE8E6,stroke:#EA4335,color:#202124',
        targetCode: 'package com.tutorial.config;\n\nimport org.apache.kafka.common.TopicPartition;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.kafka.listener.CommonErrorHandler;\nimport org.springframework.kafka.listener.DeadLetterPublishingRecoverer;\nimport org.springframework.kafka.listener.DefaultErrorHandler;\nimport org.springframework.util.backoff.FixedBackOff;\n\n@Configuration\npublic class KafkaErrorConfig {\n    private static final Logger log = LoggerFactory.getLogger(KafkaErrorConfig.class);\n\n    @Bean\n    public CommonErrorHandler errorHandler(KafkaTemplate<String, String> template) {\n        DeadLetterPublishingRecoverer recoverer = new DeadLetterPublishingRecoverer(\n                template,\n                (record, ex) -> new TopicPartition(\n                        record.topic() + ".DLQ", record.partition()));\n\n        DefaultErrorHandler handler = new DefaultErrorHandler(\n                recoverer,\n                new FixedBackOff(1000L, 3L));\n\n        handler.addNotRetryableExceptions(\n                IllegalArgumentException.class,\n                com.fasterxml.jackson.core.JsonParseException.class);\n\n        return handler;\n    }\n}\n',
        comments: [
            { line: 14, text: '// Kafka 错误处理配置类' },
            { line: 20, text: '// DLQ 恢复器：失败消息发送到原 topic + ".DLQ"' },
            { line: 25, text: '// 固定退避：每次重试间隔1秒，最多重试3次' },
            { line: 29, text: '// 不可重试异常：解析错误直接进入 DLQ，不浪费重试' },
        ],
    },
    {
        id: 'be-3-task', type: 'backend',
        title: '实战：Kafka 订单事件 + DLQ',
        category: '模块3：事件驱动与容错', track: '后端工程',
        moduleNumber: 3, lessonNumber: 3, language: 'java',
        startingCode: '',
        instructions: '# 启发式任务：Kafka 订单事件生产者 + 死信队列\n\n## 任务目标\n构建订单事件生产者，配置 DLQ 处理解析失败的消息。',
        targetCode: 'package com.tutorial.service;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.tutorial.config.KafkaConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.stereotype.Service;\nimport java.util.Map;\nimport java.util.UUID;\n\n@Service\npublic class OrderEventService {\n    private static final Logger log = LoggerFactory.getLogger(OrderEventService.class);\n    private final KafkaTemplate<String, String> kafkaTemplate;\n    private final ObjectMapper objectMapper;\n\n    public OrderEventService(KafkaTemplate<String, String> kafkaTemplate,\n                             ObjectMapper objectMapper) {\n        this.kafkaTemplate = kafkaTemplate;\n        this.objectMapper = objectMapper;\n    }\n\n    public String publishOrderCreated(String userId, String itemId, int quantity) {\n        String orderId = UUID.randomUUID().toString();\n        try {\n            String payload = objectMapper.writeValueAsString(Map.of(\n                    "orderId", orderId,\n                    "userId", userId,\n                    "itemId", itemId,\n                    "quantity", quantity,\n                    "status", "CREATED"));\n\n            kafkaTemplate.send(KafkaConfig.ORDER_TOPIC, orderId, payload)\n                    .whenComplete((result, ex) -> {\n                        if (ex == null) log.info("Order event sent: {}", orderId);\n                        else log.error("Failed to send order event: {}", orderId, ex);\n                    });\n        } catch (Exception e) {\n            log.error("Serialization failed for order: {}", orderId, e);\n        }\n        return orderId;\n    }\n}\n',
        comments: [
            { line: 12, text: '// @Service 订单事件发布服务' },
            { line: 34, text: '// 异步发送：whenComplete 处理发送成功/失败回调' },
        ],
    },
];
