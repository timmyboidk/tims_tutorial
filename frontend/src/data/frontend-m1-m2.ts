import type { Lesson } from '../types';

export const frontendM1M2: Lesson[] = [
    {
        id: 'fe-1-1', type: 'frontend',
        title: '课程 1.1：Vite、React 和 Tailwind 的配置',
        category: '模块1：现代基础架构', track: '前端架构',
        moduleNumber: 1, lessonNumber: 1, language: 'typescript',
        startingCode: '',
        instructions: `# Vite、React 和 Tailwind CSS 的配置\n\n## 学习目标\n- 理解 **Vite** 构建工具的配置原理\n- 掌握 React 插件与 Tailwind CSS 的集成方式\n- 配置开发服务器代理与路径别名\n\n## 核心知识点\n- \`defineConfig\` 是 Vite 的类型安全配置函数\n- \`@vitejs/plugin-react\` 提供 JSX 转换与热更新支持\n- 路径别名可简化深层目录的导入语句\n\n## 预期输出\n一个完整的 Vite 配置文件，包含 React 支持、Tailwind 集成、开发代理和路径别名。`,
        targetCode: `import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport tailwindcss from '@tailwindcss/vite';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    tailwindcss(),\n  ],\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n      '@components': path.resolve(__dirname, './src/components'),\n      '@hooks': path.resolve(__dirname, './src/hooks'),\n      '@utils': path.resolve(__dirname, './src/utils'),\n    },\n  },\n  server: {\n    port: 5173,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080',\n        changeOrigin: true,\n      },\n    },\n  },\n  build: {\n    sourcemap: true,\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n        },\n      },\n    },\n  },\n});\n`,
        comments: [
            { line: 1, text: '// 从 Vite 导入类型安全的配置函数' },
            { line: 7, text: '// 注册插件：React JSX 转换 + Tailwind 原子化 CSS' },
            { line: 12, text: '// 路径别名：用 @ 替代冗长的相对路径导入' },
            { line: 20, text: '// 开发服务器配置：代理后端API请求，避免跨域问题' },
        ],
    },
    {
        id: 'fe-1-2', type: 'frontend',
        title: '课程 1.2：React 的 TypeScript 核心概念',
        category: '模块1：现代基础架构', track: '前端架构',
        moduleNumber: 1, lessonNumber: 2, language: 'typescript',
        startingCode: `import React, { useState } from 'react';\n\nconst VideoFeedItem = ({ title, author, likes }) => {\n  const [isLiked, setIsLiked] = useState(false);\n\n  return (\n    <div className="p-4 border rounded-lg shadow-md">\n      <h3 className="text-lg font-bold">{title}</h3>\n      <p className="text-sm text-gray-500">@{author}</p>\n      <button \n        onClick={() => setIsLiked(!isLiked)}\n        className={\`mt-2 px-4 py-1 rounded \${isLiked ? 'bg-red-500 text-white' : 'bg-gray-200'}\`}\n      >\n        {isLiked ? 'Liked' : 'Like'} ({isLiked ? likes + 1 : likes})\n      </button>\n    </div>\n  );\n};\n\nexport default VideoFeedItem;`,
        instructions: `# 为高性能视频流编写类型\n\n在现代的大规模 Web 应用中，在运行时之前捕获错误至关重要。TypeScript 允许我们准确定义数据和组件状态的形状。\n\n## 1. 接口 (Interfaces)\n使用 \`interface\` 来定义你的组件接受的确切属性形状。这相当于一个严格的契约。\n\n## 2. Hooks 中的泛型 (Generics)\n虽然 React 通常能够推断状态类型，但对 \`useState<T>()\` 使用泛型可以明确限制哪些数据能进入你的本地状态，防止意外的类型转换。\n\n### 你的目标：\n在右侧，你有一个未定义类型的视频流列表项组件。请通过匹配幽灵文本来为其添加类型：\n1. 创建一个 \`VideoProps\` 接口，定义 \`title\`（字符串）、\`author\`（字符串）和 \`likes\`（数字）。\n2. 将该接口应用到函数组件上。\n3. 显式地为 \`useState\` hook 定义类型，使其仅接受布尔值。`,
        targetCode: `import React, { useState } from 'react';\n\ninterface VideoProps {\n  title: string;\n  author: string;\n  likes: number;\n}\n\nconst VideoFeedItem: React.FC<VideoProps> = ({ title, author, likes }) => {\n  const [isLiked, setIsLiked] = useState<boolean>(false);\n\n  return (\n    <div className="p-4 border rounded-lg shadow-md">\n      <h3 className="text-lg font-bold">{title}</h3>\n      <p className="text-sm text-gray-500">@{author}</p>\n      <button \n        onClick={() => setIsLiked(!isLiked)}\n        className={\`mt-2 px-4 py-1 rounded \${isLiked ? 'bg-red-500 text-white' : 'bg-gray-200'}\`}\n      >\n        {isLiked ? 'Liked' : 'Like'} ({isLiked ? likes + 1 : likes})\n      </button>\n    </div>\n  );\n};\n\nexport default VideoFeedItem;`,
        comments: [
            { line: 3, text: '// 定义进入组件的数据的确切形状' },
            { line: 9, text: '// 使用 React.FC (函数组件) 应用该接口' },
            { line: 10, text: '// 使用泛型 <boolean> 显式为 hook 定义类型' },
        ],
    },
    {
        id: 'fe-1-3', type: 'frontend',
        title: '课程 1.3：高级 TypeScript 状态机',
        category: '模块1：现代基础架构', track: '前端架构',
        moduleNumber: 1, lessonNumber: 3, language: 'typescript',
        startingCode: '',
        instructions: `# 高级 TypeScript 状态机：可区分联合体\n\n## 学习目标\n- 使用可区分联合体（Discriminated Unions）建模异步状态\n- 实现 Idle | Loading | Success | Error 四态模型\n- 让不可能的 UI 状态在编译期就报错\n\n## 核心原理\n通过 \`type\` 字段作为判别属性，TypeScript 能在 switch/if 中自动收窄类型，杜绝 \`data\` 和 \`error\` 同时存在的非法状态。`,
        targetCode: `type AsyncState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\ninterface Video {\n  id: string;\n  title: string;\n  url: string;\n  views: number;\n}\n\nfunction renderFeed(state: AsyncState<Video[]>): string {\n  switch (state.status) {\n    case 'idle':\n      return 'Ready to load';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return state.data.map(v => v.title).join(', ');\n    case 'error':\n      return state.error;\n  }\n}\n\nfunction useFeedReducer() {\n  const initialState: AsyncState<Video[]> = { status: 'idle' };\n\n  function reducer(\n    state: AsyncState<Video[]>,\n    action:\n      | { type: 'FETCH' }\n      | { type: 'SUCCESS'; data: Video[] }\n      | { type: 'ERROR'; error: string }\n  ): AsyncState<Video[]> {\n    switch (action.type) {\n      case 'FETCH':\n        return { status: 'loading' };\n      case 'SUCCESS':\n        return { status: 'success', data: action.data };\n      case 'ERROR':\n        return { status: 'error', error: action.error };\n      default:\n        return state;\n    }\n  }\n\n  return { initialState, reducer };\n}\n`,
        comments: [
            { line: 1, text: '// 可区分联合体：status 字段决定其余属性的存在' },
            { line: 14, text: '// switch 自动收窄：success 分支中 state.data 类型安全' },
            { line: 27, text: '// Reducer 配合联合体：每个 action 对应唯一的状态转换' },
        ],
    },
    {
        id: 'fe-1-task', type: 'frontend',
        title: '实战：构建类型安全的 UI 工具包',
        category: '模块1：现代基础架构', track: '前端架构',
        moduleNumber: 1, lessonNumber: 4, language: 'typescript',
        startingCode: '',
        instructions: `# 启发式任务：使用 Tailwind CSS 构建高可访问性、严格类型化的 UI 工具包\n\n## 任务目标\n用泛型和可区分联合体创建一个类型安全的 Button + Select 组件，确保所有变体在编译期受控。`,
        targetCode: `import React from 'react';\n\ntype ButtonVariant = 'primary' | 'secondary' | 'danger';\ntype ButtonSize = 'sm' | 'md' | 'lg';\n\ninterface ButtonProps {\n  variant: ButtonVariant;\n  size: ButtonSize;\n  children: React.ReactNode;\n  onClick: () => void;\n  disabled?: boolean;\n}\n\nconst sizeClasses: Record<ButtonSize, string> = {\n  sm: 'px-3 py-1.5 text-sm',\n  md: 'px-4 py-2 text-base',\n  lg: 'px-6 py-3 text-lg',\n};\n\nconst variantClasses: Record<ButtonVariant, string> = {\n  primary: 'bg-blue-600 text-white hover:bg-blue-700',\n  secondary: 'bg-gray-100 text-gray-700 hover:bg-gray-200',\n  danger: 'bg-red-600 text-white hover:bg-red-700',\n};\n\nexport function Button({ variant, size, children, onClick, disabled }: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className={\`rounded-lg font-medium transition-colors \${sizeClasses[size]} \${variantClasses[variant]} \${disabled ? 'opacity-50 cursor-not-allowed' : ''}\`}\n    >\n      {children}\n    </button>\n  );\n}\n`,
        comments: [
            { line: 3, text: '// 字面量联合：只允许这三种变体' },
            { line: 14, text: '// Record 映射：编译器确保每种 size 都有对应样式' },
        ],
    },
    {
        id: 'fe-2-1', type: 'frontend',
        title: '课程 2.1：React 渲染优化与记忆化',
        category: '模块2：组件架构与性能', track: '前端架构',
        moduleNumber: 2, lessonNumber: 1, language: 'typescript',
        startingCode: '',
        instructions: `# React 渲染生命周期和记忆化\n\n## 学习目标\n- 理解 React 重新渲染的触发条件\n- 使用 \`React.memo\` 阻止不必要的子组件渲染\n- 使用 \`useMemo\` / \`useCallback\` 缓存计算和函数引用`,
        targetCode: `import React, { useMemo, useCallback, useState } from 'react';\n\ninterface Video {\n  id: string;\n  title: string;\n  views: number;\n  category: string;\n}\n\ninterface FilterBarProps {\n  onFilter: (category: string) => void;\n  activeFilter: string;\n}\n\nconst FilterBar = React.memo(function FilterBar({\n  onFilter, activeFilter,\n}: FilterBarProps) {\n  const categories = ['All', 'Trending', 'Music', 'Gaming'];\n  return (\n    <div className="flex gap-2 mb-6">\n      {categories.map(cat => (\n        <button\n          key={cat}\n          onClick={() => onFilter(cat)}\n          className={\`px-4 py-2 rounded-full text-sm font-medium \${activeFilter === cat ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600'}\`}\n        >\n          {cat}\n        </button>\n      ))}\n    </div>\n  );\n});\n\nexport default function VideoGrid({ videos }: { videos: Video[] }) {\n  const [filter, setFilter] = useState('All');\n  const handleFilter = useCallback((cat: string) => setFilter(cat), []);\n\n  const filtered = useMemo(() => {\n    if (filter === 'All') return videos;\n    return videos.filter(v => v.category === filter);\n  }, [videos, filter]);\n\n  const totalViews = useMemo(() =>\n    filtered.reduce((sum, v) => sum + v.views, 0), [filtered]);\n\n  return (\n    <div className="p-6">\n      <FilterBar onFilter={handleFilter} activeFilter={filter} />\n      <p className="text-sm text-gray-500 mb-4">{totalViews.toLocaleString()} views</p>\n      <div className="grid grid-cols-2 gap-4">\n        {filtered.map(v => (\n          <div key={v.id} className="p-4 rounded-xl bg-gray-50">{v.title}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n`,
        comments: [
            { line: 15, text: '// React.memo：仅当 props 变化时才重新渲染' },
            { line: 36, text: '// useCallback：稳定引用，防止子组件不必要的重渲染' },
            { line: 38, text: '// useMemo：缓存过滤结果，依赖不变时跳过计算' },
        ],
    },
    {
        id: 'fe-2-2', type: 'frontend',
        title: '课程 2.2：自定义 Hooks（useDebounce、useIntersectionObserver）',
        category: '模块2：组件架构与性能', track: '前端架构',
        moduleNumber: 2, lessonNumber: 2, language: 'typescript',
        startingCode: '',
        instructions: `# 自定义 Hooks：封装复杂内部逻辑\n\n## 学习目标\n- 提取组件逻辑到可复用的自定义 Hook\n- 实现 \`useDebounce\` 处理搜索输入\n- 实现 \`useIntersectionObserver\` 实现懒加载与无限滚动`,
        targetCode: `import { useState, useEffect, useRef, useCallback } from 'react';\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nexport function useIntersectionObserver(\n  callback: () => void,\n  options?: IntersectionObserverInit\n) {\n  const targetRef = useRef<HTMLDivElement>(null);\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    const target = targetRef.current;\n    if (!target) return;\n\n    const observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) {\n        callbackRef.current();\n      }\n    }, { threshold: 0.1, ...options });\n\n    observer.observe(target);\n    return () => observer.disconnect();\n  }, [options]);\n\n  return targetRef;\n}\n\nexport function useLocalStorage<T>(\n  key: string, initialValue: T\n): [T, (value: T | ((prev: T) => T)) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch { return initialValue; }\n  });\n\n  const setValue = useCallback(\n    (value: T | ((prev: T) => T)) => {\n      setStoredValue(prev => {\n        const next = value instanceof Function ? value(prev) : value;\n        window.localStorage.setItem(key, JSON.stringify(next));\n        return next;\n      });\n    }, [key]\n  );\n\n  return [storedValue, setValue];\n}\n`,
        comments: [
            { line: 3, text: '// useDebounce：延迟更新值，减少高频请求' },
            { line: 14, text: '// useIntersectionObserver：元素进入视口时触发回调' },
            { line: 19, text: '// callbackRef 模式：避免 callback 变化导致 observer 重建' },
            { line: 38, text: '// useLocalStorage：持久化状态到浏览器' },
        ],
    },
    {
        id: 'fe-2-3', type: 'frontend',
        title: '课程 2.3：Web Workers 与主线程卸载',
        category: '模块2：组件架构与性能', track: '前端架构',
        moduleNumber: 2, lessonNumber: 3, language: 'typescript',
        startingCode: '',
        instructions: `# Web Workers 与主线程卸载\n\n## 学习目标\n- 将繁重计算（排序、过滤大型数据集）从主线程转移到 Web Worker\n- 使用 \`postMessage\` / \`onmessage\` 实现线程间通信\n- 确保媒体密集型应用中 React UI 保持 60fps 流畅\n\n## 核心原理\n主线程负责渲染和用户交互，如果被耗时计算阻塞，页面会卡顿。Web Worker 在后台线程中执行，不影响 UI 响应。`,
        targetCode: `const sortWorkerCode = \`\n  self.onmessage = function(e) {\n    const { videos, sortBy } = e.data;\n    const sorted = [...videos].sort((a, b) => {\n      if (sortBy === 'views') return b.views - a.views;\n      if (sortBy === 'date') return new Date(b.date).getTime() - new Date(a.date).getTime();\n      return a.title.localeCompare(b.title);\n    });\n    self.postMessage(sorted);\n  };\n\`;\n\nfunction createSortWorker(): Worker {\n  const blob = new Blob([sortWorkerCode], { type: 'application/javascript' });\n  return new Worker(URL.createObjectURL(blob));\n}\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\ninterface Video {\n  id: string;\n  title: string;\n  views: number;\n  date: string;\n}\n\ntype SortKey = 'views' | 'date' | 'title';\n\nexport function useSortWorker(videos: Video[], sortBy: SortKey) {\n  const [sorted, setSorted] = useState<Video[]>(videos);\n  const workerRef = useRef<Worker | null>(null);\n\n  useEffect(() => {\n    workerRef.current = createSortWorker();\n    workerRef.current.onmessage = (e: MessageEvent<Video[]>) => {\n      setSorted(e.data);\n    };\n    return () => workerRef.current?.terminate();\n  }, []);\n\n  useEffect(() => {\n    workerRef.current?.postMessage({ videos, sortBy });\n  }, [videos, sortBy]);\n\n  return sorted;\n}\n`,
        comments: [
            { line: 1, text: '// Worker 代码以字符串形式定义，通过 Blob URL 加载' },
            { line: 13, text: '// 创建 Worker：Blob 方式避免额外的 JS 文件' },
            { line: 28, text: '// useSortWorker Hook：抽象 Worker 生命周期管理' },
            { line: 37, text: '// 组件卸载时终止 Worker，防止内存泄漏' },
        ],
    },
    {
        id: 'fe-2-task', type: 'frontend',
        title: '实战：无限滚动视频流 + Web Worker 排序',
        category: '模块2：组件架构与性能', track: '前端架构',
        moduleNumber: 2, lessonNumber: 4, language: 'typescript',
        startingCode: '',
        instructions: `# 启发式任务：构建交互式、无限滚动的视频流\n\n## 任务目标\n综合 useIntersectionObserver 和 useSortWorker，构建一个无限加载的视频列表，排序逻辑在 Web Worker 中执行。`,
        targetCode: `import React, { useState, useCallback } from 'react';\nimport { useIntersectionObserver } from './hooks';\n\ninterface Video {\n  id: string;\n  title: string;\n  views: number;\n  thumbnail: string;\n}\n\nexport default function InfiniteVideoFeed() {\n  const [videos, setVideos] = useState<Video[]>([]);\n  const [page, setPage] = useState(1);\n  const [loading, setLoading] = useState(false);\n\n  const loadMore = useCallback(async () => {\n    if (loading) return;\n    setLoading(true);\n    const res = await fetch(\`/api/videos?page=\${page}&limit=20\`);\n    const newVideos: Video[] = await res.json();\n    setVideos(prev => [...prev, ...newVideos]);\n    setPage(p => p + 1);\n    setLoading(false);\n  }, [page, loading]);\n\n  const sentinelRef = useIntersectionObserver(loadMore);\n\n  return (\n    <div className="max-w-2xl mx-auto p-6">\n      <h1 className="text-2xl font-bold mb-6">Video Feed</h1>\n      <div className="space-y-4">\n        {videos.map(v => (\n          <div key={v.id} className="flex gap-4 p-4 rounded-xl bg-gray-50">\n            <img src={v.thumbnail} alt={v.title} className="w-40 h-24 rounded-lg object-cover" />\n            <div>\n              <h3 className="font-semibold">{v.title}</h3>\n              <p className="text-sm text-gray-500">{v.views.toLocaleString()} views</p>\n            </div>\n          </div>\n        ))}\n      </div>\n      <div ref={sentinelRef} className="h-10 flex items-center justify-center">\n        {loading && <span className="text-gray-400">Loading...</span>}\n      </div>\n    </div>\n  );\n}\n`,
        comments: [
            { line: 16, text: '// loadMore：分页加载，追加到已有列表' },
            { line: 26, text: '// sentinelRef：哨兵元素进入视口时自动触发下一页' },
            { line: 41, text: '// 哨兵 div：高度足够触发 IntersectionObserver' },
        ],
    },
];
